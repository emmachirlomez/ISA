# MAIN: PC[0:29]
# Main receives the arguments passed to the program
# In R2 it gets the subroutine to run
# In memory it receives the arguments which can be
# 2 lists or 1 list and 1 constant
# The function of the program is to apply various functions
# to polynomials.
# ADD: [30:59]
# This subroutine adds 2 polynomials
# SUB: [60:99]
# This subroutine subtracts 2 polynomials
# MULC: [100:179]
# This subroutine multiplies a polynomial by a constant
# MULX: [180:219]
# This function mulitplies a polynomial by it's variable


# This program effectuates various operations in polynomials
# We represent polynomials using lists:
# a0 + a1*x +  a2*(x^2)... will be represented by [a0,a1,a2...]
# We represent the polynomials in memory by saving the values in contiguous locations 
# Each polynomial is then obtained by 2 values :
# The location of the first element and the length of the polynomial
# As the program can run different operations, we decide the operation by reading R2


# Main
0: LI R1, 1; # Fixed to 1
1: LI R2, 3; # Set to subroutine
2: LI R3, 1; # Set to 1
# Loading first polynomial 
3: LI R10, 0;
4: LI R11, 8;  
# Loading the second polynomial, constant, or nothing
5: LI R12, 8;
6: LI R13, 9;

# Jumping to the specified subroutine 
# ADD
7: LI R14, 30;
8: LI R15, 1;
9: JEQ R14, R2, R15;
# SUBTRACTION
10: LI R14, 60;
11: LI R15, 2;
12: JEQ R14, R2, R15;
# MULC 
13: LI R14, 100;
14: LI R15, 3;
15: JEQ R14, R2, R15;
16: NOP;
17: NOP;
18: NOP;
# MULX 
19: LI R14, 180;
20: LI R15, 5;
21: JEQ R14, R2, R15;

22: NOP;
23: NOP;
24: NOP;
25: NOP;
26: NOP;
27: NOP;
28: NOP;
29: END; # Jump to line 29 to end the program


# ADD
30: LI R14, 37;          # pointers used to declare where to jump
31: LI R15, 39;
32: LI R9, 49;           # Loading with PC to end subroutine
33: JLT R14, R11, R13;   # Jumps to PC 34 if P2 is larger than P1
34: ADD R4, R10, R0;     # R4 is the start of the result
35: ADD R5, R11, R0;     # R5 is the length of the result
36: JR R15;              # 34 and 35 are only executed if P2 is larger than P1

37: ADD R4, R10, R0;     # sets the start and length in case P2 is the largest poly
38: ADD R5, R13, R0;

39: LD R6, R10;         # Load first value of p1
40: LD R7, R12;         # Load first value of p2
41: ADD R8, R6, R7;     # Sum elements
42: SD R0, R12;
43: SD R8, R4;          # Save the sum to memory location (value R4)

44: ADD R10, R10, R1;   # Increment R10 by 1
45: ADD R12, R12, R1;   # Increment R12 by 1
46: ADD R4, R4, R1;     # Increment R4 by 1
47: JLT R9, R5, R4;     # Breaks the loop in case R5<R4
48: JR R15;             # Loops back to instruction 37

49: ADD R4, R0, R14;    # Sets R4 back to the start of the result
50: ADD R11, R0, R5;    # Sets R11 to the length of the result
51: LI R3, 29;          # Sets pointer to the end of the program
52: JR R3;              # Quiting 

53: NOP;
54: NOP;
55: NOP;
56: NOP;
57: NOP;
58: NOP;
59: NOP;

# SUB
60: LI R14, 67;          # pointers used to declare where to jump
61: LI R15, 69;
62: LI R9, 79;           # Loading with PC to end subroutine
63: JLT R14, R11, R13;   # Jumps to PC 34 if P2 is larger than P1
64: ADD R4, R10, R0;     # R4 is the start of the result
65: ADD R5, R11, R0;     # R5 is the length of the result
66: JR R15;              # 34 and 35 are only executed if P2 is larger than P1

67: ADD R4, R10, R0;     # sets the start and length in case P2 is the largest poly
68: ADD R5, R13, R0;

69: LD R6, R10;         # Load first value of p1
70: LD R7, R12;         # Load first value of p2
71: SUB R8, R6, R7;     # Subtract elements
72: SD R0, R12;         # Clear value in memory(R12)
73: SD R8, R4;          # Save the difference to memory location (value R4)

74: ADD R10, R10, R1;   # Increment R10 by 1
75: ADD R12, R12, R1;   # Increment R12 by 1
76: ADD R4, R4, R1;     # Increment R4 by 1
77: JLT R9, R5, R4;     # Breaks the loop in case R5<R4
78: JR R15;             # Loops back to instruction 37

79: ADD R4, R0, R14;    # Sets R4 back to the start of the result
80: ADD R11, R0, R5;    # Sets R11 to the length of the result
81: LI R3, 29;          # Sets pointer to the end of the program
82: JR R3;              # Quiting 

83: NOP;
84: NOP;
85: NOP;
86: NOP;
87: NOP;
88: NOP;
89: NOP;
90: NOP;
91: NOP;
92: NOP;
93: NOP;
94: NOP;
95: NOP;
96: NOP;
97: NOP;
98: NOP;
99: NOP;

# MULC
100: LI R5, 111;
101: LI R6, 106;
102: LI R7, 103;
103: LI R8, 29;

104: LI R4, 0;           # R4 will be the register saving the result
105: LD R15, R12;        # Loads c to register R15
106: LD R14, R10;        # Loads the elem to be multiplied

107: JEQ R5, R0, R15;    # if R15 is 0 move to next elem
108: ADD R4, R4, R14;    # recursive mult (A*B = A+A and B-1 until B = 0)

109: SUB R15, R15, R1;   # subtracts 1 from c       
110: JR R6;              # loops back with c-1
111: SD R4, R10;         # saves elem after multiplication

112: ADD R10, R10, R1;  # moves pointer R10 to next elem
113: JLT R8, R12, R10;  # ends the subroutine after going through the last elem
114: LI R3, 104;        # Loops back to step (104) if there is still elements to be multiplied
115: JR R3;
116: NOP;
117: NOP;
118: NOP;
119: NOP;
120: NOP;
121: NOP;
122: NOP;
123: NOP;
124: NOP;
125: NOP;
126: NOP;
127: NOP;
128: NOP;

129: NOP;
130: NOP;
131: NOP;
132: NOP;
133: NOP;
134: NOP;
135: NOP;
136: NOP;
137: NOP;
138: NOP;
139: NOP;
140: NOP;
141: NOP;
142: NOP;
143: NOP;
144: NOP;
145: NOP;
146: NOP;
147: NOP;
148: NOP;
149: NOP;
150: NOP;
151: NOP;
152: NOP;
153: NOP;
154: NOP;
155: NOP;
156: NOP;
157: NOP;
158: NOP;
159: NOP;
160: NOP;
161: NOP;
162: NOP;
163: NOP;
164: NOP;
165: NOP;
166: NOP;
167: NOP;
168: NOP;
169: NOP;
170: NOP;
171: NOP;
172: NOP;
173: NOP;
174: NOP;
175: NOP;
176: NOP;
177: NOP;
178: NOP;
179: NOP;


# MULX
180: LI R4, 181;         # Loading value to use on branch expression
# Loop
181: ADD R14, R11, R1;   # Set pointer R14 to the first empty location in memory after the list
182: LD R15, R11;        # Load last element of the list to R15
183: SD R15, R14;        # Save last element in the next location in memory
184: SUB R11, R11, R1;        # Shift pointer one location to the left
185: JLT R4, R10, R11;   # Loop back if R10 < R11
# Ending
186: SD R10, R0;         # Sets first element in the list to 0
187: LI R3, 29;          # Sets pointer to the end of the program 
188: JR R3;              # Quits

