# MAIN: PC[0:29]
# Main receives the arguments passed to the program
# In R2 it gets the subroutine to run
# In memory it receives the arguments which can be
# 2 lists or 1 list and 1 constant
# The function of the program is to apply various functions
# to polynomials.
# ADD: [30:59]
# This subroutine adds 2 polynomials
# SUB: [60:99]
# This subroutine subtracts 2 polynomials
# MULC: [100:139]
# This subroutine multiplies a polynomial by a constant
# MUL: [140:179]
# This function multiplies 2 polynomails
# MULX: [180:219]
# This function mulitplies a polynomial by it's variable
# Eval: [220:300]
# This function evaluates a polynomial at a given value


# This program effectuates various operations in polynomials
# We represent polynomials using lists:
# a0 + a1*x +  a2*(x^2)... will be represented by [a0,a1,a2...]
# We represent the polynomials in memory by saving the values in contiguous locations 
# Each polynomial is then obtained by 2 values :
# The location of the first element and the length of the polynomial
# As the program can run different operations, we decide the operation by reading R2


# Main
0: LI R1, 1; # Fixed to 1
1: LI R2, 1; # Set to subroutine
2: LI R3, 1; # Set to 1
# ADD, SUB and MUL get 2 polynomials as arguments
# Loading first polynomial (Random values for now)
3: LI R10, 0;
4: LI R11, 8;  
# Loading the second polynomial, constant, or nothing
5: LI R12, 8;
6: LI R13, 9;

# Jumping to the specified subroutine 
# ADD
7: LI R14, 30;
8: LI R15, 1;
9: JEQ R14, R2, R15;
# SUBTRACTION
10: LI R14, 60;
11: LI R15, 2;
12: JEQ R14, R2, R15;
# MULC 
13: LI R14, 100;
14: LI R15, 3;
15: JEQ R14, R2, R15;
# MUL 
16: LI R14, 140;
17: LI R15, 4;
18: JEQ R14, R2, R15;
# MULX 
19: LI R14, 180;
20: LI R15, 5;
21: JEQ R14, R2, R15;
# EVAL
22: LI R14, 220;
23: LI R15, 6;
24: JEQ R14, R2, R15;

25: NOP;
26: NOP;
27: NOP;
28: NOP;
29: END; # Jump to line 29 to end the program


# ADD
30: LI R14, 37;          # pointers used to declare where to jump
31: LI R15, 39;
32: LI R9, 48;           # Loading with PC to end subroutine
33: JLT R14, R11, R13;   # Jumps to PC 34 if P2 is larger than P1
34: ADD R4, R10, R0;     # R4 is the start of the result
35: ADD R5, R11, R0;     # R5 is the length of the result
36: JR R15;              # 34 and 35 are only executed if P2 is larger than P1

37: ADD R4, R10, R0;     # sets the start and length in case P2 is the largest poly
38: ADD R5, R13, R0;

39: LD R6, R10;         # Load first value of p1
40: LD R7, R12;         # Load first value of p2
41: ADD R8, R6, R7;     # Sum elements
42: SD R8, R4;          # Save the sum to memory location (value R4)

43: ADD R10, R10, R1;   # Increment R10 by 1
44: ADD R12, R12, R1;   # Increment R12 by 1
45: ADD R4, R4, R1;     # Increment R4 by 1
46: JLT R9, R5, R4;     # Breaks the loop in case R5<R4
47: JR R15;             # Loops back to instruction 37

48: ADD R4, R0, R14;     # Sets R4 back to the start of the result
49: ADD R11, R0, R5;    # Sets R11 to the length of the result
50: LI R3, 29;          # Sets pointer to the end of the program
51: JR R3;              # Quiting 

52: NOP;
53: NOP;
54: NOP;
55: NOP;
56: NOP;
57: NOP;
58: NOP;
59: NOP;

# SUB
60: NOP;
61: NOP;
62: NOP;
63: NOP;
64: NOP;
65: NOP;
66: NOP;
67: NOP;
68: NOP;
69: NOP;
70: NOP;
71: NOP;
72: NOP;
73: NOP;
74: NOP;
75: NOP;
76: NOP;
77: NOP;
78: NOP;
79: NOP;
80: NOP;
81: NOP;
82: NOP;
83: NOP;
84: NOP;
85: NOP;
86: NOP;
87: NOP;
88: NOP;
89: NOP;
90: NOP;
91: NOP;
92: NOP;
93: NOP;
94: NOP;
95: NOP;
96: NOP;
97: NOP;
98: NOP;
99: NOP;

# MULC
100: NOP;
101: NOP;
102: NOP;
103: NOP;
104: NOP;
105: NOP;
106: NOP;
107: NOP;
108: NOP;
108: NOP;
109: NOP;
110: NOP;
111: NOP;
112: NOP;
113: NOP;
114: NOP;
115: NOP;
116: NOP;
117: NOP;
118: NOP;
119: NOP;
120: NOP;
121: NOP;
122: NOP;
123: NOP;
124: NOP;
125: NOP;
126: NOP;
127: NOP;
128: NOP;
129: NOP;
130: NOP;
131: NOP;
132: NOP;
133: NOP;
134: NOP;
135: NOP;
136: NOP;
137: NOP;
138: NOP;
139: NOP;

# MUL
140: NOP;
141: NOP;
142: NOP;
143: NOP;
144: NOP;
145: NOP;
146: NOP;
147: NOP;
148: NOP;
149: NOP;
150: NOP;
151: NOP;
152: NOP;
153: NOP;
154: NOP;
155: NOP;
156: NOP;
157: NOP;
158: NOP;
159: NOP;
160: NOP;
161: NOP;
162: NOP;
163: NOP;
164: NOP;
165: NOP;
166: NOP;
167: NOP;
168: NOP;
169: NOP;
170: NOP;
171: NOP;
172: NOP;
173: NOP;
174: NOP;
175: NOP;
176: NOP;
177: NOP;
178: NOP;
179: NOP;


# MulX
180: LI R4, 181;         # Loading value to use on branch expression
# Loop
181: ADD R14, R11, R1;   # Set pointer R14 to the first empty location in memory after the list
182: LD R15, R11;        # Load last element of the list to R15
183: SD R15, R14;        # Save last element in the next location in memory
184: SUB R11, R11, R1;        # Shift pointer one location to the left
185: JLT R4, R10, R11;   # Loop back if R10 < R11
# Ending
186: SD R10, R0;         # Sets first element in the list to 0
187: LI R3, 29;          # Sets pointer to the end of the program 
188: JR R3;              # Quits
189: NOP; 
190: NOP; 
191: NOP; 
192: NOP; 
193: NOP; 
194: NOP;
195: NOP;
196: NOP;
197: NOP;
198: NOP;
199: NOP;
200: NOP;
201: NOP;
202: NOP;
203: NOP;
204: NOP;
205: NOP;
206: NOP;
207: NOP;
208: NOP;
209: NOP;
210: NOP;
211: NOP;
212: NOP;
213: NOP;
214: NOP;
215: NOP;
216: NOP;
217: NOP;
218: NOP;
219: NOP;

# EVAL
220: LI R5, 230;
221: LI R6, 225;

222: LI R4, 0;         # R4 will be the register saving the result
223: LD R15, R12;      # Loads c to register R15
224: LD R14, R10;      # Loads the elem to be multiplied
225: ADD R4, R4, R14;  # recursive mult (A*B = A+A and B-1 until B = 0)

226: JEQ R5, R0, R15;  # if R15 is 0 move to next elem
227: SUB R15, R15, R1; # subtracts 1 from c       
228: JR R6;            # loops back with c-1
229: SD R4, R10;       # saves elem after multiplication

230: ADD R10, R10, R1; # moves pointer R10 to next elem
231: JLT R9, R11, R10; # ends the subroutine after going through the last elem
232: JR R1;            # Loops back to step (2) if there is still elements to be multiplied 
233: NOP;
234: NOP;
235: NOP;
236: NOP;
237: NOP;
238: NOP;
239: NOP;
240: NOP;
241: NOP;
242: NOP;
243: NOP;
244: NOP;
245: NOP;
246: NOP;
247: NOP;
248: NOP;
249: NOP;
250: NOP;
251: NOP;
252: NOP;
253: NOP;
254: NOP;
255: NOP;
256: NOP;
257: NOP;
258: NOP;
259: NOP;
260: NOP;
261: NOP;
262: NOP;
263: NOP;
264: NOP;
265: NOP;
266: NOP;
267: NOP;
268: NOP;
269: NOP;
270: NOP;
271: NOP;
272: NOP;
273: NOP;
274: NOP;
275: NOP;
276: NOP;
277: NOP;
278: NOP;
279: NOP;
280: NOP;
